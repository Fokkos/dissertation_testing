{% extends 'base.html' %}

{% block head %}
    <title>Flask demo</title>
{% endblock %}

{% block body %}
<div id="info">Description</div>
<div class='flex'>
    <div id="container" class='overflow-x-hidden w-4/5'></div>
    <div class='w-1/5'>
        <h1>PUT OPTIONS TO EDIT THE VISUALISATION HERE</h1>
    </div>
</div>


<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
    import { FontLoader } from '/static/js/FontLoader.js';
    import { TextGeometry } from '/static/js/TextGeometry.js';

    // get average voter
    let average_voter = {
        "id": 'average_voter',
        '0': {{data.average_voter[0]}},
        '1': {{data.average_voter[1]}},
        '2': {{data.average_voter[2]}},
    }
    
    // get 10 candidates
    let candidates = []
    let candidate = {}
    {% for candidate in data.candidates[:10] %}
        candidate = {
            "id": '{{candidate.id}}',
            '0': {{candidate[0]}},
            '1': {{candidate[1]}},
            '2': {{candidate[2]}},
        }
        candidates.push(candidate)
    {% endfor %}

    const renderer = new THREE.WebGLRenderer( {antialias: true} );
    renderer.setSize( window.innerWidth * 4 / 5, window.innerHeight );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.outputEncoding = THREE.sRGBEncoding;
    //append the renderer to the container
    document.getElementById('container').appendChild( renderer.domElement );
    

    const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );
    camera.position.set( 0, 0, 100 );
    camera.lookAt( 0, 0, 0 );

    const scene = new THREE.Scene();

    // for every candidate, the material colour is randomly generated
    // could set to manual generation to evade overlap?
    const materials = [] 
    for (let i = 0; i < candidates.length; i++) {
        // make color random
        materials.push(new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } ));
    }

    // this function creates a threeJS point given three coordinates
    function createNewPoint(x, y, z) {
        return ( new THREE.Vector3( x, y, z ) );
    }

    // the maximum values for each axis are found to determine the size of the axis
    let max_x = 0
    let max_y = 0
    let max_z = 0

    // for every candidate, generate a line between itself and the average voter
    // this centers the average voter at the origin
    for (let i = 0; i < candidates.length; i++) {
        let point1 = createNewPoint(candidates[i]['0'] - average_voter['0'],
                       candidates[i]['1'] - average_voter['1'],
                       candidates[i]['2'] - average_voter['2'])

        if (Math.abs(point1.x) > max_x) {
            max_x = Math.abs(point1.x)
        }
        if (Math.abs(point1.y) > max_y) {
            max_y = Math.abs(point1.y)
        }
        if (Math.abs(point1.z) > max_z) {
            max_z = Math.abs(point1.z)
        }

        // the point of the average voter is always at the origin
        let point2 = createNewPoint(0,0,0)
        //sets the line geometry to generate the line with
        let geometry = new THREE.BufferGeometry().setFromPoints( [point1, point2] );
        // creates the line with the randomly generated line colour defined earlier
        let line = new THREE.Line( geometry, materials[i] );
        scene.add( line );
    }

    // find the largest axis to determine how frequent the axis line dashes should be
    let largest_axis = Math.max(max_x, max_y, max_z)

    // axis material is white and dashed
    const axisMaterial = new THREE.LineDashedMaterial( {
        color: 0xffffff,
        linewidth: 1,
        scale: 1,
        // dashSize is the length of the dash, gapSize is the length of the gap
        dashSize: largest_axis / 20,
        gapSize: largest_axis / 20,
    } );

    // create xyz axis
    // computeLineDistances has to be run to make the line dashed
    let x_axis = createNewPoint(max_x,0,0)
    let x_axis_end = createNewPoint(-max_x,0,0)
    let x_geometry = new THREE.BufferGeometry().setFromPoints( [x_axis, x_axis_end] );
    let x_line = new THREE.Line( x_geometry, axisMaterial );
    x_line.computeLineDistances();
    scene.add( x_line );

    let y_axis = createNewPoint(0,max_y,0)
    let y_axis_end = createNewPoint(0,-max_y,0)
    let y_geometry = new THREE.BufferGeometry().setFromPoints( [y_axis, y_axis_end] );
    let y_line = new THREE.Line( y_geometry, axisMaterial );
    y_line.computeLineDistances();
    scene.add( y_line );

    let z_axis = createNewPoint(0,0,max_z)
    let z_axis_end = createNewPoint(0,0,-max_z)
    let z_geometry = new THREE.BufferGeometry().setFromPoints( [z_axis, z_axis_end] );
    let z_line = new THREE.Line( z_geometry, axisMaterial );
    z_line.computeLineDistances();
    scene.add( z_line );
    // add text that says 'z-axis' at the end of the z_line and the other lines 
    // face camera w/ https://stackoverflow.com/questions/12919638/textgeometry-to-always-face-user

    // font loading
    // would have used a function to load the font but the three.js mesh object has to be created in the loader

    const loader = new FontLoader();
    
    let xText = 'X-axis';
    let xTextMesh; // text object
    loader.load('/static/fonts/Roboto_Regular.json', function (font) {
        const tGeometry = new TextGeometry(xText, {
            font: font,
            size: 0.2,
            height: 0.1,
            curveSegments: 12,
            bevelEnabled: false,
        });
        tGeometry.center();

        xTextMesh = new THREE.Mesh(tGeometry, [
            new THREE.MeshPhongMaterial({ emissive: 0xff0000, emissiveIntensity: 0.5}),
            new THREE.MeshPhongMaterial({ color: 0xff0000 }),
        ]);
        
        scene.add(xTextMesh);
        xTextMesh.position.set(max_x - 0.5, 0, 0);
    });

    let yText = 'Y-axis';
    let yTextMesh; // text object
    loader.load('/static/fonts/Roboto_Regular.json', function (font) {
        const tGeometry = new TextGeometry(yText, {
            font: font,
            size: 0.2,
            height: 0.1,
            curveSegments: 12,
            bevelEnabled: false,
        });
        tGeometry.center();

        yTextMesh = new THREE.Mesh(tGeometry, [
            new THREE.MeshPhongMaterial({ emissive: 0xff0000, emissiveIntensity: 0.5}),
            new THREE.MeshPhongMaterial({ color: 0xff0000 }),
        ]);
        
        scene.add(yTextMesh);
        yTextMesh.position.set(0, max_y - 0.5, 0);
    });

    let zText = 'Z-axis';
    let zTextMesh; // text object
    loader.load('/static/fonts/Roboto_Regular.json', function (font) {
        const tGeometry = new TextGeometry(zText, {
            font: font,
            size: 0.2,
            height: 0.1,
            curveSegments: 12,
            bevelEnabled: false,
        });
        tGeometry.center();

        zTextMesh = new THREE.Mesh(tGeometry, [
            new THREE.MeshPhongMaterial({ emissive: 0xff0000, emissiveIntensity: 0.5}),
            new THREE.MeshPhongMaterial({ color: 0xff0000 }),
        ]);
        
        scene.add(zTextMesh);
        zTextMesh.position.set(0, 0, max_z - 0.5);
    });


    // need to test more positions for the camera to be in
    camera.position.z = largest_axis * 2.5;
    // have the camera rotation be facing down
    scene.rotation.x = 0.2;

    // animate is ran every frame to update the scene (in this case the rotation)
    function animate() {
        requestAnimationFrame( animate );

        // rotate the scene itself rather than the camera along the y-axis
        scene.rotation.y += 0.005;
        xTextMesh.lookAt(camera.position);
        yTextMesh.lookAt(camera.position);
        zTextMesh.lookAt(camera.position);

        renderer.render( scene, camera );
    }

    animate();

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    window.addEventListener( 'resize', onWindowResize );
</script>

{% endblock %}
