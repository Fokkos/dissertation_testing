{% extends 'base.html' %}

{% block head %}
    <title>Flask demo</title>
{% endblock %}

{% block body %}
<div class='flex'>
    <div id="container" class='overflow-x-hidden w-4/5'></div>
    <div class='w-1/5'>
        <div class='font-bold text-2xl flex justify-center'>
            <h1>Settings</h1>
        </div>
        <!--here have a dropdown for the different axis settings-->
        <div class='flex justify-center'>
            <button 
                id="threeModalTrigger" 
                class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
                onclick="openModal('threeModal')">
                Edit 3D Graph
            </button>
        </div>
        <div class='font-bold text-2xl flex justify-center'>
            <h1>Key</h1>
        </div>
        <div class='flex justify-center'>
            <div class='flex flex-col'>
                {% for i in range(19) %}
                    <div class='flex items-center space-x-2'>
                        <div class='w-4 h-4' style='background-color: {{colours[i]}}'></div>
                        <p>{{data.candidates[i]['id']}}</p>
                    </div>
                {% endfor %}
            </div>
        </div>
    </div>
</div>

<!-- options modal -->
<div id="threeModal" class="modal hidden fixed inset-0 bg-transparent flex justify-center items-center w-screen">
    <div id="threeModalOverlay" class="modal-overlay bg-gray-500 bg-opacity-75 fixed inset-0 z-40"></div>
    <div class="modal-content bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4 z-50">
        <!-- Form -->
        <div class="mb-4 flex items-center justify-between">
            <h5 class="modal-title text-xl font-semibold">Create a graph</h5>
            <button
                class="close-modal flex justify-center rounded border border-gray-300 bg-[--background] hover:bg-red-400"
                id="threeModalCloseBtn"
                aria-label="Close modal"
                title="Close modal"
                onclick="closeModal('threeModal')"
                ><span class="material-icons">close</span>
            </button>
        </div>
        <div class="modal-body">
            <form action="/threejs" method="POST">
                <div class="mb-4">
                    <label class="block text-gray-700 text-sm font-bold mb-2" for="xAxis">X-Axis:</label>
                    <select name="xAxis" id="xAxis" class="w-full p-2 border border-gray-300 rounded">
                        {% for i in range(data.variables) %}
                            <option value="{{ i }}" {% if chosen_variables[0] == i %} selected {% endif %}>{{ data.variable_names[i] }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="mb-4">
                    <label class="block text-gray-700 text-sm font-bold mb-2" for="yAxis">Y-Axis:</label>
                    <select name="yAxis" id="yAxis" class="w-full p-2 border border-gray-300 rounded">
                        {% for i in range(data.variables) %}
                            <option value="{{ i }}" {% if chosen_variables[1] == i %} selected {% endif %}>{{ data.variable_names[i] }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="mb-4">
                    <label class="block text-gray-700 text-sm font-bold mb-2" for="zAxis">Z-Axis:</label>
                    <select name="zAxis" id="zAxis" class="w-full p-2 border border-gray-300 rounded">
                        {% for i in range(data.variables) %}
                            <option value="{{ i }}" {% if chosen_variables[2] == i %} selected {% endif %}>{{ data.variable_names[i] }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="flex items-center justify-between">
                    <button
                        class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
                        type="submit"
                        >Submit
                    </button>
                </div>
            </form>
        </div>
    </div>
</div>



<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
    import { FontLoader } from '/static/js/FontLoader.js';
    import { TextGeometry } from '/static/js/TextGeometry.js';

    // get average voter
    let average_voter = {
        "id": 'average_voter',
        'x': {{data.average_voter[chosen_variables[0]]}},
        'y': {{data.average_voter[chosen_variables[1]]}},
        'z': {{data.average_voter[chosen_variables[2]]}},
    }
    
    // get 10 candidates
    let candidates = []
    let candidate = {}
    {% for candidate in data.candidates[:20] %}
        candidate = {
            "id": '{{candidate.id}}',
            'x': {{candidate[chosen_variables[0]]}},
            'y': {{candidate[chosen_variables[1]]}},
            'z': {{candidate[chosen_variables[2]]}},
        }
        candidates.push(candidate)
    {% endfor %}

    const renderer = new THREE.WebGLRenderer( {antialias: true} );
    renderer.setSize( window.innerWidth * 4 / 5, window.innerHeight );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.outputEncoding = THREE.sRGBEncoding;
    //append the renderer to the container
    document.getElementById('container').appendChild( renderer.domElement );
    

    const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );
    camera.position.set( 0, 0, 100 );
    camera.lookAt( 0, 0, 0 );

    const scene = new THREE.Scene();

    // for every candidate, the material colour is randomly generated
    // could set to manual generation to evade overlap?
    const materials = [] 
    {% for i in range(20) %}
        // make color random
        materials.push(new THREE.LineBasicMaterial( { color: '{{colours[i]}}' } ));
    {% endfor %}

    // this function creates a threeJS point given three coordinates
    function createNewPoint(x, y, z) {
        return ( new THREE.Vector3( x, y, z ) );
    }

    // the maximum values for each axis are found to determine the size of the axis
    let max_x = 0
    let max_y = 0
    let max_z = 0

    // for every candidate, generate a line between itself and the average voter
    // this centers the average voter at the origin
    for (let i = 0; i < candidates.length; i++) {
        let point1 = createNewPoint(candidates[i]['x'] - average_voter['x'],
                       candidates[i]['y'] - average_voter['y'],
                       candidates[i]['z'] - average_voter['z'])

        if (Math.abs(point1.x) > max_x) {
            max_x = Math.abs(point1.x)
        }
        if (Math.abs(point1.y) > max_y) {
            max_y = Math.abs(point1.y)
        }
        if (Math.abs(point1.z) > max_z) {
            max_z = Math.abs(point1.z)
        }

        // the point of the average voter is always at the origin
        let point2 = createNewPoint(0,0,0)
        //sets the line geometry to generate the line with
        let geometry = new THREE.BufferGeometry().setFromPoints( [point1, point2] );
        // creates the line with the randomly generated line colour defined earlier
        let line = new THREE.Line( geometry, materials[i] );
        scene.add( line );
    }

    // find the largest axis to determine how frequent the axis line dashes should be
    let largest_axis = Math.max(max_x, max_y, max_z)

    // axis material is white and dashed
    const axisMaterial = new THREE.LineDashedMaterial( {
        color: 0xffffff,
        linewidth: 1,
        scale: 1,
        // dashSize is the length of the dash, gapSize is the length of the gap
        dashSize: largest_axis / 20,
        gapSize: largest_axis / 20,
    } );

    // create xyz axis
    // computeLineDistances has to be run to make the line dashed
    let x_axis = createNewPoint(max_x,0,0)
    let x_axis_end = createNewPoint(-max_x,0,0)
    let x_geometry = new THREE.BufferGeometry().setFromPoints( [x_axis, x_axis_end] );
    let x_line = new THREE.Line( x_geometry, axisMaterial );
    x_line.computeLineDistances();
    scene.add( x_line );

    let y_axis = createNewPoint(0,max_y,0)
    let y_axis_end = createNewPoint(0,-max_y,0)
    let y_geometry = new THREE.BufferGeometry().setFromPoints( [y_axis, y_axis_end] );
    let y_line = new THREE.Line( y_geometry, axisMaterial );
    y_line.computeLineDistances();
    scene.add( y_line );

    let z_axis = createNewPoint(0,0,max_z)
    let z_axis_end = createNewPoint(0,0,-max_z)
    let z_geometry = new THREE.BufferGeometry().setFromPoints( [z_axis, z_axis_end] );
    let z_line = new THREE.Line( z_geometry, axisMaterial );
    z_line.computeLineDistances();
    scene.add( z_line );
    // add text that says 'z-axis' at the end of the z_line and the other lines 
    // face camera w/ https://stackoverflow.com/questions/12919638/textgeometry-to-always-face-user

    // font loading
    // would have used a function to load the font but the three.js mesh object has to be created in the loader
    // font to json: https://gero3.github.io/facetype.js/
    const loader = new FontLoader();
    
    let xText = '{{data.variable_names[chosen_variables[0]]}}';
    let xTextMesh; // text object
    loader.load('/static/fonts/Roboto_Regular.json', function (font) {
        const tGeometry = new TextGeometry(xText, {
            font: font,
            size: 0.1,          // actually the height of the font, in user-space
            depth: 0.3,         // THICKNESS of the extruded font, in user-space
            curveSegments: 12,
            bevelEnabled: false,
        });
        tGeometry.center();

        xTextMesh = new THREE.Mesh(tGeometry, [
            new THREE.MeshPhongMaterial({ emissive: 0xff0000, emissiveIntensity: 0.5}),
            new THREE.MeshPhongMaterial({ color: 0xff0000 }),
        ]);
        
        scene.add(xTextMesh);
        xTextMesh.position.set(max_x - 0.5, 0, 0);
    });

    let yText = '{{data.variable_names[chosen_variables[1]]}}';
    let yTextMesh; // text object
    loader.load('/static/fonts/Roboto_Regular.json', function (font) {
        const tGeometry = new TextGeometry(yText, {
            font: font,
            size: 0.1,          // actually the height of the font, in user-space
            depth: 0.3,         // THICKNESS of the extruded font, in user-space
            curveSegments: 12,
            bevelEnabled: false,
        });
        tGeometry.center();

        yTextMesh = new THREE.Mesh(tGeometry, [
            new THREE.MeshPhongMaterial({ emissive: 0xff0000, emissiveIntensity: 0.5}),
            new THREE.MeshPhongMaterial({ color: 0xff0000 }),
        ]);
        
        scene.add(yTextMesh);
        yTextMesh.position.set(0, max_y - 0.5, 0);
    });

    let zText = '{{data.variable_names[chosen_variables[2]]}}';
    let zTextMesh; // text object
    loader.load('/static/fonts/Roboto_Regular.json', function (font) {
        const tGeometry = new TextGeometry(zText, {
            font: font,
            size: 0.1,          // actually the height of the font, in user-space
            depth: 0.3,         // THICKNESS of the extruded font, in user-space
            curveSegments: 12,
            bevelEnabled: false,
        });
        tGeometry.center();

        zTextMesh = new THREE.Mesh(tGeometry, [
            new THREE.MeshPhongMaterial({ emissive: 0xff0000, emissiveIntensity: 0.5}),
            new THREE.MeshPhongMaterial({ color: 0xff0000 }),
        ]);
        
        scene.add(zTextMesh);
        zTextMesh.position.set(0, 0, max_z - 0.5);
    });


    // need to test more positions for the camera to be in
    camera.position.z = largest_axis * 2.5;
    // have the camera rotation be facing down
    scene.rotation.x = 0.2;

    // animate is ran every frame to update the scene (in this case the rotation)
    function animate() {
        requestAnimationFrame( animate );

        // rotate the scene itself rather than the camera along the y-axis
        scene.rotation.y += 0.005;
        xTextMesh.lookAt(camera.position);
        yTextMesh.lookAt(camera.position);
        zTextMesh.lookAt(camera.position);

        renderer.render( scene, camera );
    }

    animate();

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    window.addEventListener( 'resize', onWindowResize );
</script>

{% endblock %}
